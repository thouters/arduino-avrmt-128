   1               		.file	"timer.c"
   2               		.arch atmega8
   3               	__SREG__ = 0x3f
   4               	__SP_H__ = 0x3e
   5               	__SP_L__ = 0x3d
   6               	__tmp_reg__ = 0
   7               	__zero_reg__ = 1
   8               		.global __do_copy_data
   9               		.global __do_clear_bss
  12               		.text
  13               	.Ltext0:
  94               	.global	TimerRTCPrescaleFactor
  95               		.section	.progmem.data,"a",@progbits
  98               	TimerRTCPrescaleFactor:
  99 0000 0000      		.word	0
 100 0002 0100      		.word	1
 101 0004 0800      		.word	8
 102 0006 2000      		.word	32
 103 0008 4000      		.word	64
 104 000a 8000      		.word	128
 105 000c 0001      		.word	256
 106 000e 0004      		.word	1024
 107               	.global	TimerPrescaleFactor
 110               	TimerPrescaleFactor:
 111 0010 0000      		.word	0
 112 0012 0100      		.word	1
 113 0014 0800      		.word	8
 114 0016 4000      		.word	64
 115 0018 0001      		.word	256
 116 001a 0004      		.word	1024
 117               		.text
 120               	.global	delay_us
 122               	delay_us:
   1:../avrlib/timer.c **** /*! \file timer.c \brief System Timer function library. */
   2:../avrlib/timer.c **** //*****************************************************************************
   3:../avrlib/timer.c **** //
   4:../avrlib/timer.c **** // File Name	: 'timer.c'
   5:../avrlib/timer.c **** // Title		: System Timer function library
   6:../avrlib/timer.c **** // Author		: Pascal Stang - Copyright (C) 2000-2002
   7:../avrlib/timer.c **** // Created		: 11/22/2000
   8:../avrlib/timer.c **** // Revised		: 07/09/2003
   9:../avrlib/timer.c **** // Version		: 1.1
  10:../avrlib/timer.c **** // Target MCU	: Atmel AVR Series
  11:../avrlib/timer.c **** // Editor Tabs	: 4
  12:../avrlib/timer.c **** //
  13:../avrlib/timer.c **** // This code is distributed under the GNU Public License
  14:../avrlib/timer.c **** //		which can be found at http://www.gnu.org/licenses/gpl.txt
  15:../avrlib/timer.c **** //
  16:../avrlib/timer.c **** //*****************************************************************************
  17:../avrlib/timer.c **** 
  18:../avrlib/timer.c **** #ifndef WIN32
  19:../avrlib/timer.c **** 	#include <avr/io.h>
  20:../avrlib/timer.c **** 	#include <avr/signal.h>
  21:../avrlib/timer.c **** 	#include <avr/interrupt.h>
  22:../avrlib/timer.c **** 	#include <avr/pgmspace.h>
  23:../avrlib/timer.c **** 	#include <avr/sleep.h>
  24:../avrlib/timer.c **** #endif
  25:../avrlib/timer.c **** 
  26:../avrlib/timer.c **** #include "global.h"
  27:../avrlib/timer.c **** #include "timer.h"
  28:../avrlib/timer.c **** 
  29:../avrlib/timer.c **** #include "rprintf.h"
  30:../avrlib/timer.c **** 
  31:../avrlib/timer.c **** // Program ROM constants
  32:../avrlib/timer.c **** // the prescale division values stored in order of timer control register index
  33:../avrlib/timer.c **** // STOP, CLK, CLK/8, CLK/64, CLK/256, CLK/1024
  34:../avrlib/timer.c **** unsigned short __attribute__ ((progmem)) TimerPrescaleFactor[] = {0,1,8,64,256,1024};
  35:../avrlib/timer.c **** // the prescale division values stored in order of timer control register index
  36:../avrlib/timer.c **** // STOP, CLK, CLK/8, CLK/32, CLK/64, CLK/128, CLK/256, CLK/1024
  37:../avrlib/timer.c **** unsigned short __attribute__ ((progmem)) TimerRTCPrescaleFactor[] = {0,1,8,32,64,128,256,1024};
  38:../avrlib/timer.c **** 
  39:../avrlib/timer.c **** // Global variables
  40:../avrlib/timer.c **** // time registers
  41:../avrlib/timer.c **** volatile unsigned long TimerPauseReg;
  42:../avrlib/timer.c **** volatile unsigned long Timer0Reg0;
  43:../avrlib/timer.c **** volatile unsigned long Timer2Reg0;
  44:../avrlib/timer.c **** 
  45:../avrlib/timer.c **** typedef void (*voidFuncPtr)(void);
  46:../avrlib/timer.c **** volatile static voidFuncPtr TimerIntFunc[TIMER_NUM_INTERRUPTS];
  47:../avrlib/timer.c **** 
  48:../avrlib/timer.c **** // delay for a minimum of <us> microseconds 
  49:../avrlib/timer.c **** // the time resolution is dependent on the time the loop takes 
  50:../avrlib/timer.c **** // e.g. with 4Mhz and 5 cycles per loop, the resolution is 1.25 us 
  51:../avrlib/timer.c **** void delay_us(unsigned short time_us) 
  52:../avrlib/timer.c **** {
 124               	.LM1:
 125               	/* prologue: frame size=0 */
 126               	/* prologue end (size=0) */
  53:../avrlib/timer.c **** 	unsigned short delay_loops;
  54:../avrlib/timer.c **** 	register unsigned short i;
  55:../avrlib/timer.c **** 
  56:../avrlib/timer.c **** 	delay_loops = (time_us+3)/5*CYCLES_PER_US; // +3 for rounding up (dirty) 
 128               	.LM2:
 129 0000 0396      		adiw r24,3
 130 0002 65E0      		ldi r22,lo8(5)
 131 0004 70E0      		ldi r23,hi8(5)
 132 0006 00D0      		rcall __udivmodhi4
 133 0008 CB01      		movw r24,r22
 134 000a AA27      		clr r26
 135 000c BB27      		clr r27
 136 000e 24E0      		ldi r18,4
 137 0010 880F      	1:	lsl r24
 138 0012 991F      		rol r25
 139 0014 AA1F      		rol r26
 140 0016 BB1F      		rol r27
 141 0018 2A95      		dec r18
 142 001a D1F7      		brne 1b
 143               	.L8:
  57:../avrlib/timer.c **** 
  58:../avrlib/timer.c **** 	// one loop takes 5 cpu cycles 
  59:../avrlib/timer.c **** 	for (i=0; i < delay_loops; i++) {};
 145               	.LM3:
 146 001c 0097      		sbiw r24,0
 147 001e 11F0      		breq .L7
 148 0020 0197      		sbiw r24,1
 149 0022 FCCF      		rjmp .L8
 150               	.L7:
 151 0024 0895      		ret
 152               	/* epilogue: frame size=0 */
 153               	/* epilogue: noreturn */
 154               	/* epilogue end (size=0) */
 155               	/* function delay_us size 19 (19) */
 161               	.Lscope0:
 165               	.global	timerDetach
 167               	timerDetach:
  60:../avrlib/timer.c **** }
  61:../avrlib/timer.c **** /*
  62:../avrlib/timer.c **** void delay_ms(unsigned char time_ms)
  63:../avrlib/timer.c **** {
  64:../avrlib/timer.c **** 	unsigned short delay_count = F_CPU / 4000;
  65:../avrlib/timer.c **** 
  66:../avrlib/timer.c **** 	unsigned short cnt;
  67:../avrlib/timer.c **** 	asm volatile ("\n"
  68:../avrlib/timer.c ****                   "L_dl1%=:\n\t"
  69:../avrlib/timer.c ****                   "mov %A0, %A2\n\t"
  70:../avrlib/timer.c ****                   "mov %B0, %B2\n"
  71:../avrlib/timer.c ****                   "L_dl2%=:\n\t"
  72:../avrlib/timer.c ****                   "sbiw %A0, 1\n\t"
  73:../avrlib/timer.c ****                   "brne L_dl2%=\n\t"
  74:../avrlib/timer.c ****                   "dec %1\n\t" "brne L_dl1%=\n\t":"=&w" (cnt)
  75:../avrlib/timer.c ****                   :"r"(time_ms), "r"((unsigned short) (delay_count))
  76:../avrlib/timer.c **** 	);
  77:../avrlib/timer.c **** }
  78:../avrlib/timer.c **** */
  79:../avrlib/timer.c **** void timerInit(void)
  80:../avrlib/timer.c **** {
  81:../avrlib/timer.c **** 	u08 intNum;
  82:../avrlib/timer.c **** 	// detach all user functions from interrupts
  83:../avrlib/timer.c **** 	for(intNum=0; intNum<TIMER_NUM_INTERRUPTS; intNum++)
  84:../avrlib/timer.c **** 		timerDetach(intNum);
  85:../avrlib/timer.c **** 
  86:../avrlib/timer.c **** 	// initialize all timers
  87:../avrlib/timer.c **** 	timer0Init();
  88:../avrlib/timer.c **** 	timer1Init();
  89:../avrlib/timer.c **** 	#ifdef TCNT2	// support timer2 only if it exists
  90:../avrlib/timer.c **** 	timer2Init();
  91:../avrlib/timer.c **** 	#endif
  92:../avrlib/timer.c **** 	// enable interrupts
  93:../avrlib/timer.c **** 	sei();
  94:../avrlib/timer.c **** }
  95:../avrlib/timer.c **** 
  96:../avrlib/timer.c **** void timer0Init()
  97:../avrlib/timer.c **** {
  98:../avrlib/timer.c **** 	// initialize timer 0
  99:../avrlib/timer.c **** 	timer0SetPrescaler( TIMER0PRESCALE );	// set prescaler
 100:../avrlib/timer.c **** 	outb(TCNT0, 0);							// reset TCNT0
 101:../avrlib/timer.c **** 	sbi(TIMSK, TOIE0);						// enable TCNT0 overflow interrupt
 102:../avrlib/timer.c **** 
 103:../avrlib/timer.c **** 	timer0ClearOverflowCount();				// initialize time registers
 104:../avrlib/timer.c **** }
 105:../avrlib/timer.c **** 
 106:../avrlib/timer.c **** void timer1Init(void)
 107:../avrlib/timer.c **** {
 108:../avrlib/timer.c **** 	// initialize timer 1
 109:../avrlib/timer.c **** 	timer1SetPrescaler( TIMER1PRESCALE );	// set prescaler
 110:../avrlib/timer.c **** 	outb(TCNT1H, 0);						// reset TCNT1
 111:../avrlib/timer.c **** 	outb(TCNT1L, 0);
 112:../avrlib/timer.c **** 	sbi(TIMSK, TOIE1);						// enable TCNT1 overflow
 113:../avrlib/timer.c **** }
 114:../avrlib/timer.c **** 
 115:../avrlib/timer.c **** #ifdef TCNT2	// support timer2 only if it exists
 116:../avrlib/timer.c **** void timer2Init(void)
 117:../avrlib/timer.c **** {
 118:../avrlib/timer.c **** 	// initialize timer 2
 119:../avrlib/timer.c **** 	timer2SetPrescaler( TIMER2PRESCALE );	// set prescaler
 120:../avrlib/timer.c **** 	outb(TCNT2, 0);							// reset TCNT2
 121:../avrlib/timer.c **** 	sbi(TIMSK, TOIE2);						// enable TCNT2 overflow
 122:../avrlib/timer.c **** 
 123:../avrlib/timer.c **** 	timer2ClearOverflowCount();				// initialize time registers
 124:../avrlib/timer.c **** }
 125:../avrlib/timer.c **** #endif
 126:../avrlib/timer.c **** 
 127:../avrlib/timer.c **** void timer0SetPrescaler(u08 prescale)
 128:../avrlib/timer.c **** {
 129:../avrlib/timer.c **** 	// set prescaler on timer 0
 130:../avrlib/timer.c **** 	outb(TCCR0, (inb(TCCR0) & ~TIMER_PRESCALE_MASK) | prescale);
 131:../avrlib/timer.c **** }
 132:../avrlib/timer.c **** 
 133:../avrlib/timer.c **** void timer1SetPrescaler(u08 prescale)
 134:../avrlib/timer.c **** {
 135:../avrlib/timer.c **** 	// set prescaler on timer 1
 136:../avrlib/timer.c **** 	outb(TCCR1B, (inb(TCCR1B) & ~TIMER_PRESCALE_MASK) | prescale);
 137:../avrlib/timer.c **** }
 138:../avrlib/timer.c **** 
 139:../avrlib/timer.c **** #ifdef TCNT2	// support timer2 only if it exists
 140:../avrlib/timer.c **** void timer2SetPrescaler(u08 prescale)
 141:../avrlib/timer.c **** {
 142:../avrlib/timer.c **** 	// set prescaler on timer 2
 143:../avrlib/timer.c **** 	outb(TCCR2, (inb(TCCR2) & ~TIMER_PRESCALE_MASK) | prescale);
 144:../avrlib/timer.c **** }
 145:../avrlib/timer.c **** #endif
 146:../avrlib/timer.c **** 
 147:../avrlib/timer.c **** u16 timer0GetPrescaler(void)
 148:../avrlib/timer.c **** {
 149:../avrlib/timer.c **** 	// get the current prescaler setting
 150:../avrlib/timer.c **** 	return (pgm_read_word(TimerPrescaleFactor+(inb(TCCR0) & TIMER_PRESCALE_MASK)));
 151:../avrlib/timer.c **** }
 152:../avrlib/timer.c **** 
 153:../avrlib/timer.c **** u16 timer1GetPrescaler(void)
 154:../avrlib/timer.c **** {
 155:../avrlib/timer.c **** 	// get the current prescaler setting
 156:../avrlib/timer.c **** 	return (pgm_read_word(TimerPrescaleFactor+(inb(TCCR1B) & TIMER_PRESCALE_MASK)));
 157:../avrlib/timer.c **** }
 158:../avrlib/timer.c **** 
 159:../avrlib/timer.c **** #ifdef TCNT2	// support timer2 only if it exists
 160:../avrlib/timer.c **** u16 timer2GetPrescaler(void)
 161:../avrlib/timer.c **** {
 162:../avrlib/timer.c **** 	//TODO: can we assume for all 3-timer AVR processors,
 163:../avrlib/timer.c **** 	// that timer2 is the RTC timer?
 164:../avrlib/timer.c **** 
 165:../avrlib/timer.c **** 	// get the current prescaler setting
 166:../avrlib/timer.c **** 	return (pgm_read_word(TimerRTCPrescaleFactor+(inb(TCCR2) & TIMER_PRESCALE_MASK)));
 167:../avrlib/timer.c **** }
 168:../avrlib/timer.c **** #endif
 169:../avrlib/timer.c **** 
 170:../avrlib/timer.c **** void timerAttach(u08 interruptNum, void (*userFunc)(void) )
 171:../avrlib/timer.c **** {
 172:../avrlib/timer.c **** 	// make sure the interrupt number is within bounds
 173:../avrlib/timer.c **** 	if(interruptNum < TIMER_NUM_INTERRUPTS)
 174:../avrlib/timer.c **** 	{
 175:../avrlib/timer.c **** 		// set the interrupt function to run
 176:../avrlib/timer.c **** 		// the supplied user's function
 177:../avrlib/timer.c **** 		TimerIntFunc[interruptNum] = userFunc;
 178:../avrlib/timer.c **** 	}
 179:../avrlib/timer.c **** }
 180:../avrlib/timer.c **** 
 181:../avrlib/timer.c **** void timerDetach(u08 interruptNum)
 182:../avrlib/timer.c **** {
 169               	.LM4:
 170               	/* prologue: frame size=0 */
 171               	/* prologue end (size=0) */
 183:../avrlib/timer.c **** 	// make sure the interrupt number is within bounds
 184:../avrlib/timer.c **** 	if(interruptNum < TIMER_NUM_INTERRUPTS)
 173               	.LM5:
 174 0026 8730      		cpi r24,lo8(7)
 175 0028 40F4      		brsh .L9
 185:../avrlib/timer.c **** 	{
 186:../avrlib/timer.c **** 		// set the interrupt function to run nothing
 187:../avrlib/timer.c **** 		TimerIntFunc[interruptNum] = 0;
 177               	.LM6:
 178 002a E82F      		mov r30,r24
 179 002c FF27      		clr r31
 180 002e EE0F      		add r30,r30
 181 0030 FF1F      		adc r31,r31
 182 0032 E050      		subi r30,lo8(-(TimerIntFunc))
 183 0034 F040      		sbci r31,hi8(-(TimerIntFunc))
 184 0036 1082      		st Z,__zero_reg__
 185 0038 1182      		std Z+1,__zero_reg__
 186               	.L9:
 187 003a 0895      		ret
 188               	/* epilogue: frame size=0 */
 189 003c 0895      		ret
 190               	/* epilogue end (size=1) */
 191               	/* function timerDetach size 12 (11) */
 193               	.Lscope1:
 197               	.global	timer0SetPrescaler
 199               	timer0SetPrescaler:
 201               	.LM7:
 202               	/* prologue: frame size=0 */
 203               	/* prologue end (size=0) */
 205               	.LM8:
 206 003e 93B7      		in r25,83-0x20
 207 0040 987F      		andi r25,lo8(-8)
 208 0042 982B      		or r25,r24
 209 0044 93BF      		out 83-0x20,r25
 210               	/* epilogue: frame size=0 */
 211 0046 0895      		ret
 212               	/* epilogue end (size=1) */
 213               	/* function timer0SetPrescaler size 5 (4) */
 215               	.Lscope2:
 218               	.global	timer0ClearOverflowCount
 220               	timer0ClearOverflowCount:
 188:../avrlib/timer.c **** 	}
 189:../avrlib/timer.c **** }
 190:../avrlib/timer.c **** /*
 191:../avrlib/timer.c **** u32 timerMsToTics(u16 ms)
 192:../avrlib/timer.c **** {
 193:../avrlib/timer.c **** 	// calculate the prescaler division rate
 194:../avrlib/timer.c **** 	u16 prescaleDiv = 1<<(pgm_read_byte(TimerPrescaleFactor+inb(TCCR0)));
 195:../avrlib/timer.c **** 	// calculate the number of timer tics in x milliseconds
 196:../avrlib/timer.c **** 	return (ms*(F_CPU/(prescaleDiv*256)))/1000;
 197:../avrlib/timer.c **** }
 198:../avrlib/timer.c **** 
 199:../avrlib/timer.c **** u16 timerTicsToMs(u32 tics)
 200:../avrlib/timer.c **** {
 201:../avrlib/timer.c **** 	// calculate the prescaler division rate
 202:../avrlib/timer.c **** 	u16 prescaleDiv = 1<<(pgm_read_byte(TimerPrescaleFactor+inb(TCCR0)));
 203:../avrlib/timer.c **** 	// calculate the number of milliseconds in x timer tics
 204:../avrlib/timer.c **** 	return (tics*1000*(prescaleDiv*256))/F_CPU;
 205:../avrlib/timer.c **** }
 206:../avrlib/timer.c **** */
 207:../avrlib/timer.c **** void timerPause(unsigned short pause_ms)
 208:../avrlib/timer.c **** {
 209:../avrlib/timer.c **** 	// pauses for exactly <pause_ms> number of milliseconds
 210:../avrlib/timer.c **** 	u08 timerThres;
 211:../avrlib/timer.c **** 	u32 ticRateHz;
 212:../avrlib/timer.c **** 	u32 pause;
 213:../avrlib/timer.c **** 
 214:../avrlib/timer.c **** 	// capture current pause timer value
 215:../avrlib/timer.c **** 	timerThres = inb(TCNT0);
 216:../avrlib/timer.c **** 	// reset pause timer overflow count
 217:../avrlib/timer.c **** 	TimerPauseReg = 0;
 218:../avrlib/timer.c **** 	// calculate delay for [pause_ms] milliseconds
 219:../avrlib/timer.c **** 	// prescaler division = 1<<(pgm_read_byte(TimerPrescaleFactor+inb(TCCR0)))
 220:../avrlib/timer.c **** 	ticRateHz = F_CPU/timer0GetPrescaler();
 221:../avrlib/timer.c **** 	// precision management
 222:../avrlib/timer.c **** 	// prevent overflow and precision underflow
 223:../avrlib/timer.c **** 	//	-could add more conditions to improve accuracy
 224:../avrlib/timer.c **** 	if( ((ticRateHz < 429497) && (pause_ms <= 10000)) )
 225:../avrlib/timer.c **** 		pause = (pause_ms*ticRateHz)/1000;
 226:../avrlib/timer.c **** 	else
 227:../avrlib/timer.c **** 		pause = pause_ms*(ticRateHz/1000);
 228:../avrlib/timer.c **** 
 229:../avrlib/timer.c **** 	// loop until time expires
 230:../avrlib/timer.c **** 	while( ((TimerPauseReg<<8) | inb(TCNT0)) < (pause+timerThres) )
 231:../avrlib/timer.c **** 	{
 232:../avrlib/timer.c **** 		if( TimerPauseReg < (pause>>8));
 233:../avrlib/timer.c **** 		{
 234:../avrlib/timer.c **** 			// save power by idling the processor
 235:../avrlib/timer.c **** 			set_sleep_mode(SLEEP_MODE_IDLE);
 236:../avrlib/timer.c **** 			sleep_mode();
 237:../avrlib/timer.c **** 		}
 238:../avrlib/timer.c **** 	}
 239:../avrlib/timer.c **** 
 240:../avrlib/timer.c **** 	/* old inaccurate code, for reference
 241:../avrlib/timer.c **** 	
 242:../avrlib/timer.c **** 	// calculate delay for [pause_ms] milliseconds
 243:../avrlib/timer.c **** 	u16 prescaleDiv = 1<<(pgm_read_byte(TimerPrescaleFactor+inb(TCCR0)));
 244:../avrlib/timer.c **** 	u32 pause = (pause_ms*(F_CPU/(prescaleDiv*256)))/1000;
 245:../avrlib/timer.c **** 	
 246:../avrlib/timer.c **** 	TimerPauseReg = 0;
 247:../avrlib/timer.c **** 	while(TimerPauseReg < pause);
 248:../avrlib/timer.c **** 
 249:../avrlib/timer.c **** 	*/
 250:../avrlib/timer.c **** }
 251:../avrlib/timer.c **** 
 252:../avrlib/timer.c **** void timer0ClearOverflowCount(void)
 253:../avrlib/timer.c **** {
 222               	.LM9:
 223               	/* prologue: frame size=0 */
 224               	/* prologue end (size=0) */
 254:../avrlib/timer.c **** 	// clear the timer overflow counter registers
 255:../avrlib/timer.c **** 	Timer0Reg0 = 0;	// initialize time registers
 226               	.LM10:
 227 0048 1092 0000 		sts Timer0Reg0,__zero_reg__
 228 004c 1092 0000 		sts (Timer0Reg0)+1,__zero_reg__
 229 0050 1092 0000 		sts (Timer0Reg0)+2,__zero_reg__
 230 0054 1092 0000 		sts (Timer0Reg0)+3,__zero_reg__
 231               	/* epilogue: frame size=0 */
 232 0058 0895      		ret
 233               	/* epilogue end (size=1) */
 234               	/* function timer0ClearOverflowCount size 9 (8) */
 236               	.Lscope3:
 239               	.global	timer0Init
 241               	timer0Init:
 243               	.LM11:
 244               	/* prologue: frame size=0 */
 245               	/* prologue end (size=0) */
 247               	.LM12:
 248 005a 82E0      		ldi r24,lo8(2)
 249 005c F0DF      		rcall timer0SetPrescaler
 251               	.LM13:
 252 005e 12BE      		out 82-0x20,__zero_reg__
 254               	.LM14:
 255 0060 89B7      		in r24,89-0x20
 256 0062 8160      		ori r24,lo8(1)
 257 0064 89BF      		out 89-0x20,r24
 259               	.LM15:
 260 0066 F0DF      		rcall timer0ClearOverflowCount
 261               	/* epilogue: frame size=0 */
 262 0068 0895      		ret
 263               	/* epilogue end (size=1) */
 264               	/* function timer0Init size 8 (7) */
 266               	.Lscope4:
 270               	.global	timer1SetPrescaler
 272               	timer1SetPrescaler:
 274               	.LM16:
 275               	/* prologue: frame size=0 */
 276               	/* prologue end (size=0) */
 278               	.LM17:
 279 006a 9EB5      		in r25,78-0x20
 280 006c 987F      		andi r25,lo8(-8)
 281 006e 982B      		or r25,r24
 282 0070 9EBD      		out 78-0x20,r25
 283               	/* epilogue: frame size=0 */
 284 0072 0895      		ret
 285               	/* epilogue end (size=1) */
 286               	/* function timer1SetPrescaler size 5 (4) */
 288               	.Lscope5:
 291               	.global	timer1Init
 293               	timer1Init:
 295               	.LM18:
 296               	/* prologue: frame size=0 */
 297               	/* prologue end (size=0) */
 299               	.LM19:
 300 0074 83E0      		ldi r24,lo8(3)
 301 0076 F9DF      		rcall timer1SetPrescaler
 303               	.LM20:
 304 0078 1DBC      		out 77-0x20,__zero_reg__
 306               	.LM21:
 307 007a 1CBC      		out 76-0x20,__zero_reg__
 309               	.LM22:
 310 007c 89B7      		in r24,89-0x20
 311 007e 8460      		ori r24,lo8(4)
 312 0080 89BF      		out 89-0x20,r24
 313               	/* epilogue: frame size=0 */
 314 0082 0895      		ret
 315               	/* epilogue end (size=1) */
 316               	/* function timer1Init size 8 (7) */
 318               	.Lscope6:
 322               	.global	timer2SetPrescaler
 324               	timer2SetPrescaler:
 326               	.LM23:
 327               	/* prologue: frame size=0 */
 328               	/* prologue end (size=0) */
 330               	.LM24:
 331 0084 95B5      		in r25,69-0x20
 332 0086 987F      		andi r25,lo8(-8)
 333 0088 982B      		or r25,r24
 334 008a 95BD      		out 69-0x20,r25
 335               	/* epilogue: frame size=0 */
 336 008c 0895      		ret
 337               	/* epilogue end (size=1) */
 338               	/* function timer2SetPrescaler size 5 (4) */
 340               	.Lscope7:
 343               	.global	timer2ClearOverflowCount
 345               	timer2ClearOverflowCount:
 256:../avrlib/timer.c **** }
 257:../avrlib/timer.c **** 
 258:../avrlib/timer.c **** long timer0GetOverflowCount(void)
 259:../avrlib/timer.c **** {
 260:../avrlib/timer.c **** 	// return the current timer overflow count
 261:../avrlib/timer.c **** 	// (this is since the last timer0ClearOverflowCount() command was called)
 262:../avrlib/timer.c **** 	return Timer0Reg0;
 263:../avrlib/timer.c **** }
 264:../avrlib/timer.c **** 
 265:../avrlib/timer.c **** #ifdef TCNT2	// support timer2 only if it exists
 266:../avrlib/timer.c **** void timer2ClearOverflowCount(void)
 267:../avrlib/timer.c **** {
 347               	.LM25:
 348               	/* prologue: frame size=0 */
 349               	/* prologue end (size=0) */
 268:../avrlib/timer.c **** 	// clear the timer overflow counter registers
 269:../avrlib/timer.c **** 	Timer2Reg0 = 0;	// initialize time registers
 351               	.LM26:
 352 008e 1092 0000 		sts Timer2Reg0,__zero_reg__
 353 0092 1092 0000 		sts (Timer2Reg0)+1,__zero_reg__
 354 0096 1092 0000 		sts (Timer2Reg0)+2,__zero_reg__
 355 009a 1092 0000 		sts (Timer2Reg0)+3,__zero_reg__
 356               	/* epilogue: frame size=0 */
 357 009e 0895      		ret
 358               	/* epilogue end (size=1) */
 359               	/* function timer2ClearOverflowCount size 9 (8) */
 361               	.Lscope8:
 364               	.global	timer2Init
 366               	timer2Init:
 368               	.LM27:
 369               	/* prologue: frame size=0 */
 370               	/* prologue end (size=0) */
 372               	.LM28:
 373 00a0 84E0      		ldi r24,lo8(4)
 374 00a2 F0DF      		rcall timer2SetPrescaler
 376               	.LM29:
 377 00a4 14BC      		out 68-0x20,__zero_reg__
 379               	.LM30:
 380 00a6 89B7      		in r24,89-0x20
 381 00a8 8064      		ori r24,lo8(64)
 382 00aa 89BF      		out 89-0x20,r24
 384               	.LM31:
 385 00ac F0DF      		rcall timer2ClearOverflowCount
 386               	/* epilogue: frame size=0 */
 387 00ae 0895      		ret
 388               	/* epilogue end (size=1) */
 389               	/* function timer2Init size 8 (7) */
 391               	.Lscope9:
 394               	.global	timerInit
 396               	timerInit:
 398               	.LM32:
 399               	/* prologue: frame size=0 */
 400 00b0 CF93      		push r28
 401               	/* prologue end (size=1) */
 403               	.LM33:
 404 00b2 C0E0      		ldi r28,lo8(0)
 405               	.L23:
 407               	.LM34:
 408 00b4 8C2F      		mov r24,r28
 409 00b6 B7DF      		rcall timerDetach
 411               	.LM35:
 412 00b8 CF5F      		subi r28,lo8(-(1))
 413 00ba C730      		cpi r28,lo8(7)
 414 00bc D8F3      		brlo .L23
 416               	.LM36:
 417 00be CDDF      		rcall timer0Init
 419               	.LM37:
 420 00c0 D9DF      		rcall timer1Init
 422               	.LM38:
 423 00c2 EEDF      		rcall timer2Init
 425               	.LM39:
 426               	/* #APP */
 427 00c4 7894      		sei
 428               	/* #NOAPP */
 429               	/* epilogue: frame size=0 */
 430 00c6 CF91      		pop r28
 431 00c8 0895      		ret
 432               	/* epilogue end (size=2) */
 433               	/* function timerInit size 14 (11) */
 438               	.Lscope10:
 441               	.global	timer0GetPrescaler
 443               	timer0GetPrescaler:
 445               	.LM40:
 446               	/* prologue: frame size=0 */
 447               	/* prologue end (size=0) */
 448               	.LBB2:
 450               	.LM41:
 451 00ca 83B7      		in r24,83-0x20
 452 00cc E82F      		mov r30,r24
 453 00ce FF27      		clr r31
 454 00d0 E770      		andi r30,lo8(7)
 455 00d2 F070      		andi r31,hi8(7)
 456 00d4 EE0F      		add r30,r30
 457 00d6 FF1F      		adc r31,r31
 458 00d8 E050      		subi r30,lo8(-(TimerPrescaleFactor))
 459 00da F040      		sbci r31,hi8(-(TimerPrescaleFactor))
 460               	.LBE2:
 462               	.LM42:
 463               	/* #APP */
 464 00dc 8591      		lpm r24, Z+
 465 00de 9491      		lpm r25, Z
 466               		
 467               	/* #NOAPP */
 468               	/* epilogue: frame size=0 */
 469 00e0 0895      		ret
 470               	/* epilogue end (size=1) */
 471               	/* function timer0GetPrescaler size 16 (15) */
 476               	.Lscope11:
 479               	.global	timer1GetPrescaler
 481               	timer1GetPrescaler:
 483               	.LM43:
 484               	/* prologue: frame size=0 */
 485               	/* prologue end (size=0) */
 486               	.LBB3:
 488               	.LM44:
 489 00e2 8EB5      		in r24,78-0x20
 490 00e4 E82F      		mov r30,r24
 491 00e6 FF27      		clr r31
 492 00e8 E770      		andi r30,lo8(7)
 493 00ea F070      		andi r31,hi8(7)
 494 00ec EE0F      		add r30,r30
 495 00ee FF1F      		adc r31,r31
 496 00f0 E050      		subi r30,lo8(-(TimerPrescaleFactor))
 497 00f2 F040      		sbci r31,hi8(-(TimerPrescaleFactor))
 498               	.LBE3:
 500               	.LM45:
 501               	/* #APP */
 502 00f4 8591      		lpm r24, Z+
 503 00f6 9491      		lpm r25, Z
 504               		
 505               	/* #NOAPP */
 506               	/* epilogue: frame size=0 */
 507 00f8 0895      		ret
 508               	/* epilogue end (size=1) */
 509               	/* function timer1GetPrescaler size 16 (15) */
 514               	.Lscope12:
 517               	.global	timer2GetPrescaler
 519               	timer2GetPrescaler:
 521               	.LM46:
 522               	/* prologue: frame size=0 */
 523               	/* prologue end (size=0) */
 524               	.LBB4:
 526               	.LM47:
 527 00fa 85B5      		in r24,69-0x20
 528 00fc E82F      		mov r30,r24
 529 00fe FF27      		clr r31
 530 0100 E770      		andi r30,lo8(7)
 531 0102 F070      		andi r31,hi8(7)
 532 0104 EE0F      		add r30,r30
 533 0106 FF1F      		adc r31,r31
 534 0108 E050      		subi r30,lo8(-(TimerRTCPrescaleFactor))
 535 010a F040      		sbci r31,hi8(-(TimerRTCPrescaleFactor))
 536               	.LBE4:
 538               	.LM48:
 539               	/* #APP */
 540 010c 8591      		lpm r24, Z+
 541 010e 9491      		lpm r25, Z
 542               		
 543               	/* #NOAPP */
 544               	/* epilogue: frame size=0 */
 545 0110 0895      		ret
 546               	/* epilogue end (size=1) */
 547               	/* function timer2GetPrescaler size 16 (15) */
 552               	.Lscope13:
 557               	.global	timerAttach
 559               	timerAttach:
 561               	.LM49:
 562               	/* prologue: frame size=0 */
 563               	/* prologue end (size=0) */
 565               	.LM50:
 566 0112 8730      		cpi r24,lo8(7)
 567 0114 40F4      		brsh .L29
 569               	.LM51:
 570 0116 E82F      		mov r30,r24
 571 0118 FF27      		clr r31
 572 011a EE0F      		add r30,r30
 573 011c FF1F      		adc r31,r31
 574 011e E050      		subi r30,lo8(-(TimerIntFunc))
 575 0120 F040      		sbci r31,hi8(-(TimerIntFunc))
 576 0122 6083      		st Z,r22
 577 0124 7183      		std Z+1,r23
 578               	.L29:
 579 0126 0895      		ret
 580               	/* epilogue: frame size=0 */
 581 0128 0895      		ret
 582               	/* epilogue end (size=1) */
 583               	/* function timerAttach size 12 (11) */
 585               	.Lscope14:
 589               	.global	timerPause
 591               	timerPause:
 593               	.LM52:
 594               	/* prologue: frame size=0 */
 595 012a DF92      		push r13
 596 012c EF92      		push r14
 597 012e FF92      		push r15
 598 0130 0F93      		push r16
 599 0132 1F93      		push r17
 600 0134 CF93      		push r28
 601 0136 DF93      		push r29
 602               	/* prologue end (size=7) */
 603 0138 EC01      		movw r28,r24
 605               	.LM53:
 606 013a D2B6      		in r13,82-0x20
 608               	.LM54:
 609 013c 1092 0000 		sts TimerPauseReg,__zero_reg__
 610 0140 1092 0000 		sts (TimerPauseReg)+1,__zero_reg__
 611 0144 1092 0000 		sts (TimerPauseReg)+2,__zero_reg__
 612 0148 1092 0000 		sts (TimerPauseReg)+3,__zero_reg__
 614               	.LM55:
 615 014c BEDF      		rcall timer0GetPrescaler
 616 014e 9C01      		movw r18,r24
 617 0150 4427      		clr r20
 618 0152 5527      		clr r21
 619 0154 60E0      		ldi r22,lo8(16000000)
 620 0156 74E2      		ldi r23,hi8(16000000)
 621 0158 84EF      		ldi r24,hlo8(16000000)
 622 015a 90E0      		ldi r25,hhi8(16000000)
 623 015c 00D0      		rcall __divmodsi4
 625               	.LM56:
 626 015e 293B      		cpi r18,lo8(429497)
 627 0160 8DE8      		ldi r24,hi8(429497)
 628 0162 3807      		cpc r19,r24
 629 0164 86E0      		ldi r24,hlo8(429497)
 630 0166 4807      		cpc r20,r24
 631 0168 80E0      		ldi r24,hhi8(429497)
 632 016a 5807      		cpc r21,r24
 633 016c B0F4      		brsh .L32
 635               	.LM57:
 636 016e 87E2      		ldi r24,hi8(10001)
 637 0170 C131      		cpi r28,lo8(10001)
 638 0172 D807      		cpc r29,r24
 639 0174 90F4      		brsh .L32
 641               	.LM58:
 642 0176 CE01      		movw r24,r28
 643 0178 AA27      		clr r26
 644 017a BB27      		clr r27
 645 017c BC01      		movw r22,r24
 646 017e CD01      		movw r24,r26
 647 0180 00D0      		rcall __mulsi3
 648 0182 DC01      		movw r26,r24
 649 0184 CB01      		movw r24,r22
 650 0186 BC01      		movw r22,r24
 651 0188 CD01      		movw r24,r26
 652 018a 28EE      		ldi r18,lo8(1000)
 653 018c 33E0      		ldi r19,hi8(1000)
 654 018e 40E0      		ldi r20,hlo8(1000)
 655 0190 50E0      		ldi r21,hhi8(1000)
 656 0192 00D0      		rcall __udivmodsi4
 657 0194 FA01      		movw r30,r20
 658 0196 E901      		movw r28,r18
 659 0198 0FC0      		rjmp .L33
 660               	.L32:
 662               	.LM59:
 663 019a 7E01      		movw r14,r28
 664 019c 0027      		clr r16
 665 019e 1127      		clr r17
 666 01a0 CA01      		movw r24,r20
 667 01a2 B901      		movw r22,r18
 668 01a4 28EE      		ldi r18,lo8(1000)
 669 01a6 33E0      		ldi r19,hi8(1000)
 670 01a8 40E0      		ldi r20,hlo8(1000)
 671 01aa 50E0      		ldi r21,hhi8(1000)
 672 01ac 00D0      		rcall __udivmodsi4
 673 01ae C801      		movw r24,r16
 674 01b0 B701      		movw r22,r14
 675 01b2 00D0      		rcall __mulsi3
 676 01b4 FC01      		movw r30,r24
 677 01b6 EB01      		movw r28,r22
 678               	.L33:
 680               	.LM60:
 681 01b8 8091 0000 		lds r24,TimerPauseReg
 682 01bc 9091 0000 		lds r25,(TimerPauseReg)+1
 683 01c0 A091 0000 		lds r26,(TimerPauseReg)+2
 684 01c4 B091 0000 		lds r27,(TimerPauseReg)+3
 685 01c8 2227      		clr r18
 686 01ca 382F      		mov r19,r24
 687 01cc 492F      		mov r20,r25
 688 01ce 5A2F      		mov r21,r26
 689 01d0 82B7      		in r24,82-0x20
 690 01d2 9927      		clr r25
 691 01d4 AA27      		clr r26
 692 01d6 BB27      		clr r27
 693 01d8 282B      		or r18,r24
 694 01da 392B      		or r19,r25
 695 01dc 4A2B      		or r20,r26
 696 01de 5B2B      		or r21,r27
 697 01e0 CD0D      		add r28,r13
 698 01e2 D11D      		adc r29,__zero_reg__
 699 01e4 E11D      		adc r30,__zero_reg__
 700 01e6 F11D      		adc r31,__zero_reg__
 701 01e8 2C17      		cp r18,r28
 702 01ea 3D07      		cpc r19,r29
 703 01ec 4E07      		cpc r20,r30
 704 01ee 5F07      		cpc r21,r31
 705 01f0 58F5      		brsh .L41
 706               	.L39:
 708               	.LM61:
 709 01f2 8091 0000 		lds r24,TimerPauseReg
 710 01f6 9091 0000 		lds r25,(TimerPauseReg)+1
 711 01fa A091 0000 		lds r26,(TimerPauseReg)+2
 712 01fe B091 0000 		lds r27,(TimerPauseReg)+3
 714               	.LM62:
 715 0202 85B7      		in r24,85-0x20
 716 0204 8F78      		andi r24,lo8(-113)
 717 0206 85BF      		out 85-0x20,r24
 719               	.LM63:
 720 0208 85B7      		in r24,85-0x20
 721 020a 8068      		ori r24,lo8(-128)
 722 020c 85BF      		out 85-0x20,r24
 723               	/* #APP */
 724 020e 8895      		sleep
 725               		
 726               	/* #NOAPP */
 727 0210 85B7      		in r24,85-0x20
 728 0212 8F77      		andi r24,lo8(127)
 729 0214 85BF      		out 85-0x20,r24
 730 0216 8091 0000 		lds r24,TimerPauseReg
 731 021a 9091 0000 		lds r25,(TimerPauseReg)+1
 732 021e A091 0000 		lds r26,(TimerPauseReg)+2
 733 0222 B091 0000 		lds r27,(TimerPauseReg)+3
 734 0226 BA2F      		mov r27,r26
 735 0228 A92F      		mov r26,r25
 736 022a 982F      		mov r25,r24
 737 022c 8827      		clr r24
 738 022e 22B7      		in r18,82-0x20
 739 0230 3327      		clr r19
 740 0232 4427      		clr r20
 741 0234 5527      		clr r21
 742 0236 822B      		or r24,r18
 743 0238 932B      		or r25,r19
 744 023a A42B      		or r26,r20
 745 023c B52B      		or r27,r21
 746 023e 8C17      		cp r24,r28
 747 0240 9D07      		cpc r25,r29
 748 0242 AE07      		cpc r26,r30
 749 0244 BF07      		cpc r27,r31
 750 0246 A8F2      		brlo .L39
 751               	.L41:
 752               	/* epilogue: frame size=0 */
 753 0248 DF91      		pop r29
 754 024a CF91      		pop r28
 755 024c 1F91      		pop r17
 756 024e 0F91      		pop r16
 757 0250 FF90      		pop r15
 758 0252 EF90      		pop r14
 759 0254 DF90      		pop r13
 760 0256 0895      		ret
 761               	/* epilogue end (size=8) */
 762               	/* function timerPause size 154 (139) */
 769               	.Lscope15:
 772               	.global	timer0GetOverflowCount
 774               	timer0GetOverflowCount:
 776               	.LM64:
 777               	/* prologue: frame size=0 */
 778               	/* prologue end (size=0) */
 780               	.LM65:
 781 0258 8091 0000 		lds r24,Timer0Reg0
 782 025c 9091 0000 		lds r25,(Timer0Reg0)+1
 783 0260 A091 0000 		lds r26,(Timer0Reg0)+2
 784 0264 B091 0000 		lds r27,(Timer0Reg0)+3
 786               	.LM66:
 787 0268 BC01      		movw r22,r24
 788 026a CD01      		movw r24,r26
 789               	/* epilogue: frame size=0 */
 790 026c 0895      		ret
 791               	/* epilogue end (size=1) */
 792               	/* function timer0GetOverflowCount size 11 (10) */
 794               	.Lscope16:
 797               	.global	timer2GetOverflowCount
 799               	timer2GetOverflowCount:
 270:../avrlib/timer.c **** }
 271:../avrlib/timer.c **** 
 272:../avrlib/timer.c **** long timer2GetOverflowCount(void)
 273:../avrlib/timer.c **** {
 801               	.LM67:
 802               	/* prologue: frame size=0 */
 803               	/* prologue end (size=0) */
 274:../avrlib/timer.c **** 	// return the current timer overflow count
 275:../avrlib/timer.c **** 	// (this is since the last timer2ClearOverflowCount() command was called)
 276:../avrlib/timer.c **** 	return Timer2Reg0;
 805               	.LM68:
 806 026e 8091 0000 		lds r24,Timer2Reg0
 807 0272 9091 0000 		lds r25,(Timer2Reg0)+1
 808 0276 A091 0000 		lds r26,(Timer2Reg0)+2
 809 027a B091 0000 		lds r27,(Timer2Reg0)+3
 277:../avrlib/timer.c **** }
 811               	.LM69:
 812 027e BC01      		movw r22,r24
 813 0280 CD01      		movw r24,r26
 814               	/* epilogue: frame size=0 */
 815 0282 0895      		ret
 816               	/* epilogue end (size=1) */
 817               	/* function timer2GetOverflowCount size 11 (10) */
 819               	.Lscope17:
 823               	.global	timer1PWMInit
 825               	timer1PWMInit:
 278:../avrlib/timer.c **** #endif
 279:../avrlib/timer.c **** 
 280:../avrlib/timer.c **** void timer1PWMInit(u08 bitRes)
 281:../avrlib/timer.c **** {
 827               	.LM70:
 828               	/* prologue: frame size=0 */
 829               	/* prologue end (size=0) */
 282:../avrlib/timer.c **** 	// configures timer1 for use with PWM output
 283:../avrlib/timer.c **** 	// on OC1A and OC1B pins
 284:../avrlib/timer.c **** 
 285:../avrlib/timer.c **** 	// enable timer1 as 8,9,10bit PWM
 286:../avrlib/timer.c **** 	if(bitRes == 9)
 831               	.LM71:
 832 0284 8930      		cpi r24,lo8(9)
 833 0286 31F4      		brne .L45
 287:../avrlib/timer.c **** 	{	// 9bit mode
 288:../avrlib/timer.c **** 		sbi(TCCR1A,PWM11);
 835               	.LM72:
 836 0288 8FB5      		in r24,79-0x20
 837 028a 8260      		ori r24,lo8(2)
 838 028c 8FBD      		out 79-0x20,r24
 289:../avrlib/timer.c **** 		cbi(TCCR1A,PWM10);
 840               	.LM73:
 841 028e 8FB5      		in r24,79-0x20
 842 0290 8E7F      		andi r24,lo8(-2)
 843 0292 0AC0      		rjmp .L50
 844               	.L45:
 290:../avrlib/timer.c **** 	}
 291:../avrlib/timer.c **** 	else if( bitRes == 10 )
 846               	.LM74:
 847 0294 8A30      		cpi r24,lo8(10)
 848 0296 19F4      		brne .L47
 292:../avrlib/timer.c **** 	{	// 10bit mode
 293:../avrlib/timer.c **** 		sbi(TCCR1A,PWM11);
 850               	.LM75:
 851 0298 8FB5      		in r24,79-0x20
 852 029a 8260      		ori r24,lo8(2)
 853 029c 02C0      		rjmp .L49
 854               	.L47:
 294:../avrlib/timer.c **** 		sbi(TCCR1A,PWM10);
 295:../avrlib/timer.c **** 	}
 296:../avrlib/timer.c **** 	else
 297:../avrlib/timer.c **** 	{	// default 8bit mode
 298:../avrlib/timer.c **** 		cbi(TCCR1A,PWM11);
 856               	.LM76:
 857 029e 8FB5      		in r24,79-0x20
 858 02a0 8D7F      		andi r24,lo8(-3)
 859               	.L49:
 860 02a2 8FBD      		out 79-0x20,r24
 299:../avrlib/timer.c **** 		sbi(TCCR1A,PWM10);
 862               	.LM77:
 863 02a4 8FB5      		in r24,79-0x20
 864 02a6 8160      		ori r24,lo8(1)
 865               	.L50:
 866 02a8 8FBD      		out 79-0x20,r24
 300:../avrlib/timer.c **** 	}
 301:../avrlib/timer.c **** 
 302:../avrlib/timer.c **** 	// clear output compare value A
 303:../avrlib/timer.c **** 	outb(OCR1AH, 0);
 868               	.LM78:
 869 02aa 1BBC      		out 75-0x20,__zero_reg__
 304:../avrlib/timer.c **** 	outb(OCR1AL, 0);
 871               	.LM79:
 872 02ac 1ABC      		out 74-0x20,__zero_reg__
 305:../avrlib/timer.c **** 	// clear output compare value B
 306:../avrlib/timer.c **** 	outb(OCR1BH, 0);
 874               	.LM80:
 875 02ae 19BC      		out 73-0x20,__zero_reg__
 307:../avrlib/timer.c **** 	outb(OCR1BL, 0);
 877               	.LM81:
 878 02b0 18BC      		out 72-0x20,__zero_reg__
 879               	/* epilogue: frame size=0 */
 880 02b2 0895      		ret
 881               	/* epilogue end (size=1) */
 882               	/* function timer1PWMInit size 24 (23) */
 884               	.Lscope18:
 888               	.global	timer1PWMInitICR
 890               	timer1PWMInitICR:
 308:../avrlib/timer.c **** }
 309:../avrlib/timer.c **** 
 310:../avrlib/timer.c **** #ifdef WGM10
 311:../avrlib/timer.c **** // include support for arbitrary top-count PWM
 312:../avrlib/timer.c **** // on new AVR processors that support it
 313:../avrlib/timer.c **** void timer1PWMInitICR(u16 topcount)
 314:../avrlib/timer.c **** {
 892               	.LM82:
 893               	/* prologue: frame size=0 */
 894               	/* prologue end (size=0) */
 895 02b4 9C01      		movw r18,r24
 315:../avrlib/timer.c **** 	// set PWM mode with ICR top-count
 316:../avrlib/timer.c **** 	cbi(TCCR1A,WGM10);
 897               	.LM83:
 898 02b6 8FB5      		in r24,79-0x20
 899 02b8 8E7F      		andi r24,lo8(-2)
 900 02ba 8FBD      		out 79-0x20,r24
 317:../avrlib/timer.c **** 	sbi(TCCR1A,WGM11);
 902               	.LM84:
 903 02bc 8FB5      		in r24,79-0x20
 904 02be 8260      		ori r24,lo8(2)
 905 02c0 8FBD      		out 79-0x20,r24
 318:../avrlib/timer.c **** 	sbi(TCCR1B,WGM12);
 907               	.LM85:
 908 02c2 8EB5      		in r24,78-0x20
 909 02c4 8860      		ori r24,lo8(8)
 910 02c6 8EBD      		out 78-0x20,r24
 319:../avrlib/timer.c **** 	sbi(TCCR1B,WGM13);
 912               	.LM86:
 913 02c8 8EB5      		in r24,78-0x20
 914 02ca 8061      		ori r24,lo8(16)
 915 02cc 8EBD      		out 78-0x20,r24
 320:../avrlib/timer.c **** 	
 321:../avrlib/timer.c **** 	// set top count value
 322:../avrlib/timer.c **** 	ICR1 = topcount;
 917               	.LM87:
 918 02ce 37BD      		out (70)+1-0x20,r19
 919 02d0 26BD      		out 70-0x20,r18
 323:../avrlib/timer.c **** 	
 324:../avrlib/timer.c **** 	// clear output compare value A
 325:../avrlib/timer.c **** 	OCR1A = 0;
 921               	.LM88:
 922 02d2 1BBC      		out (74)+1-0x20,__zero_reg__
 923 02d4 1ABC      		out 74-0x20,__zero_reg__
 326:../avrlib/timer.c **** 	// clear output compare value B
 327:../avrlib/timer.c **** 	OCR1B = 0;
 925               	.LM89:
 926 02d6 19BC      		out (72)+1-0x20,__zero_reg__
 927 02d8 18BC      		out 72-0x20,__zero_reg__
 928               	/* epilogue: frame size=0 */
 929 02da 0895      		ret
 930               	/* epilogue end (size=1) */
 931               	/* function timer1PWMInitICR size 20 (19) */
 933               	.Lscope19:
 936               	.global	timer1PWMAOff
 938               	timer1PWMAOff:
 328:../avrlib/timer.c **** 
 329:../avrlib/timer.c **** }
 330:../avrlib/timer.c **** #endif
 331:../avrlib/timer.c **** 
 332:../avrlib/timer.c **** void timer1PWMOff(void)
 333:../avrlib/timer.c **** {
 334:../avrlib/timer.c **** 	// turn off timer1 PWM mode
 335:../avrlib/timer.c **** 	cbi(TCCR1A,PWM11);
 336:../avrlib/timer.c **** 	cbi(TCCR1A,PWM10);
 337:../avrlib/timer.c **** 	// set PWM1A/B (OutputCompare action) to none
 338:../avrlib/timer.c **** 	timer1PWMAOff();
 339:../avrlib/timer.c **** 	timer1PWMBOff();
 340:../avrlib/timer.c **** }
 341:../avrlib/timer.c **** 
 342:../avrlib/timer.c **** void timer1PWMAOn(void)
 343:../avrlib/timer.c **** {
 344:../avrlib/timer.c **** 	// turn on channel A (OC1A) PWM output
 345:../avrlib/timer.c **** 	// set OC1A as non-inverted PWM
 346:../avrlib/timer.c **** 	sbi(TCCR1A,COM1A1);
 347:../avrlib/timer.c **** 	cbi(TCCR1A,COM1A0);
 348:../avrlib/timer.c **** }
 349:../avrlib/timer.c **** 
 350:../avrlib/timer.c **** void timer1PWMBOn(void)
 351:../avrlib/timer.c **** {
 352:../avrlib/timer.c **** 	// turn on channel B (OC1B) PWM output
 353:../avrlib/timer.c **** 	// set OC1B as non-inverted PWM
 354:../avrlib/timer.c **** 	sbi(TCCR1A,COM1B1);
 355:../avrlib/timer.c **** 	cbi(TCCR1A,COM1B0);
 356:../avrlib/timer.c **** }
 357:../avrlib/timer.c **** 
 358:../avrlib/timer.c **** void timer1PWMAOff(void)
 359:../avrlib/timer.c **** {
 940               	.LM90:
 941               	/* prologue: frame size=0 */
 942               	/* prologue end (size=0) */
 360:../avrlib/timer.c **** 	// turn off channel A (OC1A) PWM output
 361:../avrlib/timer.c **** 	// set OC1A (OutputCompare action) to none
 362:../avrlib/timer.c **** 	cbi(TCCR1A,COM1A1);
 944               	.LM91:
 945 02dc 8FB5      		in r24,79-0x20
 946 02de 8F77      		andi r24,lo8(127)
 947 02e0 8FBD      		out 79-0x20,r24
 363:../avrlib/timer.c **** 	cbi(TCCR1A,COM1A0);
 949               	.LM92:
 950 02e2 8FB5      		in r24,79-0x20
 951 02e4 8F7B      		andi r24,lo8(-65)
 952 02e6 8FBD      		out 79-0x20,r24
 953               	/* epilogue: frame size=0 */
 954 02e8 0895      		ret
 955               	/* epilogue end (size=1) */
 956               	/* function timer1PWMAOff size 7 (6) */
 958               	.Lscope20:
 961               	.global	timer1PWMBOff
 963               	timer1PWMBOff:
 364:../avrlib/timer.c **** }
 365:../avrlib/timer.c **** 
 366:../avrlib/timer.c **** void timer1PWMBOff(void)
 367:../avrlib/timer.c **** {
 965               	.LM93:
 966               	/* prologue: frame size=0 */
 967               	/* prologue end (size=0) */
 368:../avrlib/timer.c **** 	// turn off channel B (OC1B) PWM output
 369:../avrlib/timer.c **** 	// set OC1B (OutputCompare action) to none
 370:../avrlib/timer.c **** 	cbi(TCCR1A,COM1B1);
 969               	.LM94:
 970 02ea 8FB5      		in r24,79-0x20
 971 02ec 8F7D      		andi r24,lo8(-33)
 972 02ee 8FBD      		out 79-0x20,r24
 371:../avrlib/timer.c **** 	cbi(TCCR1A,COM1B0);
 974               	.LM95:
 975 02f0 8FB5      		in r24,79-0x20
 976 02f2 8F7E      		andi r24,lo8(-17)
 977 02f4 8FBD      		out 79-0x20,r24
 978               	/* epilogue: frame size=0 */
 979 02f6 0895      		ret
 980               	/* epilogue end (size=1) */
 981               	/* function timer1PWMBOff size 7 (6) */
 983               	.Lscope21:
 986               	.global	timer1PWMOff
 988               	timer1PWMOff:
 990               	.LM96:
 991               	/* prologue: frame size=0 */
 992               	/* prologue end (size=0) */
 994               	.LM97:
 995 02f8 8FB5      		in r24,79-0x20
 996 02fa 8D7F      		andi r24,lo8(-3)
 997 02fc 8FBD      		out 79-0x20,r24
 999               	.LM98:
 1000 02fe 8FB5      		in r24,79-0x20
 1001 0300 8E7F      		andi r24,lo8(-2)
 1002 0302 8FBD      		out 79-0x20,r24
 1004               	.LM99:
 1005 0304 EBDF      		rcall timer1PWMAOff
 1007               	.LM100:
 1008 0306 F1DF      		rcall timer1PWMBOff
 1009               	/* epilogue: frame size=0 */
 1010 0308 0895      		ret
 1011               	/* epilogue end (size=1) */
 1012               	/* function timer1PWMOff size 9 (8) */
 1014               	.Lscope22:
 1017               	.global	timer1PWMAOn
 1019               	timer1PWMAOn:
 1021               	.LM101:
 1022               	/* prologue: frame size=0 */
 1023               	/* prologue end (size=0) */
 1025               	.LM102:
 1026 030a 8FB5      		in r24,79-0x20
 1027 030c 8068      		ori r24,lo8(-128)
 1028 030e 8FBD      		out 79-0x20,r24
 1030               	.LM103:
 1031 0310 8FB5      		in r24,79-0x20
 1032 0312 8F7B      		andi r24,lo8(-65)
 1033 0314 8FBD      		out 79-0x20,r24
 1034               	/* epilogue: frame size=0 */
 1035 0316 0895      		ret
 1036               	/* epilogue end (size=1) */
 1037               	/* function timer1PWMAOn size 7 (6) */
 1039               	.Lscope23:
 1042               	.global	timer1PWMBOn
 1044               	timer1PWMBOn:
 1046               	.LM104:
 1047               	/* prologue: frame size=0 */
 1048               	/* prologue end (size=0) */
 1050               	.LM105:
 1051 0318 8FB5      		in r24,79-0x20
 1052 031a 8062      		ori r24,lo8(32)
 1053 031c 8FBD      		out 79-0x20,r24
 1055               	.LM106:
 1056 031e 8FB5      		in r24,79-0x20
 1057 0320 8F7E      		andi r24,lo8(-17)
 1058 0322 8FBD      		out 79-0x20,r24
 1059               	/* epilogue: frame size=0 */
 1060 0324 0895      		ret
 1061               	/* epilogue end (size=1) */
 1062               	/* function timer1PWMBOn size 7 (6) */
 1064               	.Lscope24:
 1068               	.global	timer1PWMASet
 1070               	timer1PWMASet:
 372:../avrlib/timer.c **** }
 373:../avrlib/timer.c **** 
 374:../avrlib/timer.c **** void timer1PWMASet(u16 pwmDuty)
 375:../avrlib/timer.c **** {
 1072               	.LM107:
 1073               	/* prologue: frame size=0 */
 1074               	/* prologue end (size=0) */
 376:../avrlib/timer.c **** 	// set PWM (output compare) duty for channel A
 377:../avrlib/timer.c **** 	// this PWM output is generated on OC1A pin
 378:../avrlib/timer.c **** 	// NOTE:	pwmDuty should be in the range 0-255 for 8bit PWM
 379:../avrlib/timer.c **** 	//			pwmDuty should be in the range 0-511 for 9bit PWM
 380:../avrlib/timer.c **** 	//			pwmDuty should be in the range 0-1023 for 10bit PWM
 381:../avrlib/timer.c **** 	//outp( (pwmDuty>>8), OCR1AH);		// set the high 8bits of OCR1A
 382:../avrlib/timer.c **** 	//outp( (pwmDuty&0x00FF), OCR1AL);	// set the low 8bits of OCR1A
 383:../avrlib/timer.c **** 	OCR1A = pwmDuty;
 1076               	.LM108:
 1077 0326 9BBD      		out (74)+1-0x20,r25
 1078 0328 8ABD      		out 74-0x20,r24
 1079               	/* epilogue: frame size=0 */
 1080 032a 0895      		ret
 1081               	/* epilogue end (size=1) */
 1082               	/* function timer1PWMASet size 3 (2) */
 1084               	.Lscope25:
 1088               	.global	timer1PWMBSet
 1090               	timer1PWMBSet:
 384:../avrlib/timer.c **** }
 385:../avrlib/timer.c **** 
 386:../avrlib/timer.c **** void timer1PWMBSet(u16 pwmDuty)
 387:../avrlib/timer.c **** {
 1092               	.LM109:
 1093               	/* prologue: frame size=0 */
 1094               	/* prologue end (size=0) */
 388:../avrlib/timer.c **** 	// set PWM (output compare) duty for channel B
 389:../avrlib/timer.c **** 	// this PWM output is generated on OC1B pin
 390:../avrlib/timer.c **** 	// NOTE:	pwmDuty should be in the range 0-255 for 8bit PWM
 391:../avrlib/timer.c **** 	//			pwmDuty should be in the range 0-511 for 9bit PWM
 392:../avrlib/timer.c **** 	//			pwmDuty should be in the range 0-1023 for 10bit PWM
 393:../avrlib/timer.c **** 	//outp( (pwmDuty>>8), OCR1BH);		// set the high 8bits of OCR1B
 394:../avrlib/timer.c **** 	//outp( (pwmDuty&0x00FF), OCR1BL);	// set the low 8bits of OCR1B
 395:../avrlib/timer.c **** 	OCR1B = pwmDuty;
 1096               	.LM110:
 1097 032c 99BD      		out (72)+1-0x20,r25
 1098 032e 88BD      		out 72-0x20,r24
 1099               	/* epilogue: frame size=0 */
 1100 0330 0895      		ret
 1101               	/* epilogue end (size=1) */
 1102               	/* function timer1PWMBSet size 3 (2) */
 1104               	.Lscope26:
 1107               	.global	__vector_9
 1109               	__vector_9:
 396:../avrlib/timer.c **** }
 397:../avrlib/timer.c **** 
 398:../avrlib/timer.c **** //! Interrupt handler for tcnt0 overflow interrupt
 399:../avrlib/timer.c **** TIMER_INTERRUPT_HANDLER(SIG_OVERFLOW0)
 400:../avrlib/timer.c **** {
 1111               	.LM111:
 1112               	/* prologue: frame size=0 */
 1113 0332 1F92      		push __zero_reg__
 1114 0334 0F92      		push __tmp_reg__
 1115 0336 0FB6      		in __tmp_reg__,__SREG__
 1116 0338 0F92      		push __tmp_reg__
 1117 033a 1124      		clr __zero_reg__
 1118 033c 2F93      		push r18
 1119 033e 3F93      		push r19
 1120 0340 4F93      		push r20
 1121 0342 5F93      		push r21
 1122 0344 6F93      		push r22
 1123 0346 7F93      		push r23
 1124 0348 8F93      		push r24
 1125 034a 9F93      		push r25
 1126 034c AF93      		push r26
 1127 034e BF93      		push r27
 1128 0350 EF93      		push r30
 1129 0352 FF93      		push r31
 1130               	/* prologue end (size=17) */
 401:../avrlib/timer.c **** 	Timer0Reg0++;			// increment low-order counter
 1132               	.LM112:
 1133 0354 8091 0000 		lds r24,Timer0Reg0
 1134 0358 9091 0000 		lds r25,(Timer0Reg0)+1
 1135 035c A091 0000 		lds r26,(Timer0Reg0)+2
 1136 0360 B091 0000 		lds r27,(Timer0Reg0)+3
 1137 0364 0196      		adiw r24,1
 1138 0366 A11D      		adc r26,__zero_reg__
 1139 0368 B11D      		adc r27,__zero_reg__
 1140 036a 8093 0000 		sts Timer0Reg0,r24
 1141 036e 9093 0000 		sts (Timer0Reg0)+1,r25
 1142 0372 A093 0000 		sts (Timer0Reg0)+2,r26
 1143 0376 B093 0000 		sts (Timer0Reg0)+3,r27
 402:../avrlib/timer.c **** 
 403:../avrlib/timer.c **** 	// increment pause counter
 404:../avrlib/timer.c **** 	TimerPauseReg++;
 1145               	.LM113:
 1146 037a 8091 0000 		lds r24,TimerPauseReg
 1147 037e 9091 0000 		lds r25,(TimerPauseReg)+1
 1148 0382 A091 0000 		lds r26,(TimerPauseReg)+2
 1149 0386 B091 0000 		lds r27,(TimerPauseReg)+3
 1150 038a 0196      		adiw r24,1
 1151 038c A11D      		adc r26,__zero_reg__
 1152 038e B11D      		adc r27,__zero_reg__
 1153 0390 8093 0000 		sts TimerPauseReg,r24
 1154 0394 9093 0000 		sts (TimerPauseReg)+1,r25
 1155 0398 A093 0000 		sts (TimerPauseReg)+2,r26
 1156 039c B093 0000 		sts (TimerPauseReg)+3,r27
 405:../avrlib/timer.c **** 
 406:../avrlib/timer.c **** 	// if a user function is defined, execute it too
 407:../avrlib/timer.c **** 	if(TimerIntFunc[TIMER0OVERFLOW_INT])
 1158               	.LM114:
 1159 03a0 8091 0000 		lds r24,TimerIntFunc
 1160 03a4 9091 0000 		lds r25,(TimerIntFunc)+1
 1161 03a8 892B      		or r24,r25
 1162 03aa 29F0      		breq .L59
 408:../avrlib/timer.c **** 		TimerIntFunc[TIMER0OVERFLOW_INT]();
 1164               	.LM115:
 1165 03ac E091 0000 		lds r30,TimerIntFunc
 1166 03b0 F091 0000 		lds r31,(TimerIntFunc)+1
 1167 03b4 0995      		icall
 1168               	.L59:
 1169               	/* epilogue: frame size=0 */
 1170 03b6 FF91      		pop r31
 1171 03b8 EF91      		pop r30
 1172 03ba BF91      		pop r27
 1173 03bc AF91      		pop r26
 1174 03be 9F91      		pop r25
 1175 03c0 8F91      		pop r24
 1176 03c2 7F91      		pop r23
 1177 03c4 6F91      		pop r22
 1178 03c6 5F91      		pop r21
 1179 03c8 4F91      		pop r20
 1180 03ca 3F91      		pop r19
 1181 03cc 2F91      		pop r18
 1182 03ce 0F90      		pop __tmp_reg__
 1183 03d0 0FBE      		out __SREG__,__tmp_reg__
 1184 03d2 0F90      		pop __tmp_reg__
 1185 03d4 1F90      		pop __zero_reg__
 1186 03d6 1895      		reti
 1187               	/* epilogue end (size=17) */
 1188               	/* function __vector_9 size 83 (49) */
 1190               	.Lscope27:
 1193               	.global	__vector_8
 1195               	__vector_8:
 409:../avrlib/timer.c **** }
 410:../avrlib/timer.c **** 
 411:../avrlib/timer.c **** //! Interrupt handler for tcnt1 overflow interrupt
 412:../avrlib/timer.c **** TIMER_INTERRUPT_HANDLER(SIG_OVERFLOW1)
 413:../avrlib/timer.c **** {
 1197               	.LM116:
 1198               	/* prologue: frame size=0 */
 1199 03d8 1F92      		push __zero_reg__
 1200 03da 0F92      		push __tmp_reg__
 1201 03dc 0FB6      		in __tmp_reg__,__SREG__
 1202 03de 0F92      		push __tmp_reg__
 1203 03e0 1124      		clr __zero_reg__
 1204 03e2 2F93      		push r18
 1205 03e4 3F93      		push r19
 1206 03e6 4F93      		push r20
 1207 03e8 5F93      		push r21
 1208 03ea 6F93      		push r22
 1209 03ec 7F93      		push r23
 1210 03ee 8F93      		push r24
 1211 03f0 9F93      		push r25
 1212 03f2 AF93      		push r26
 1213 03f4 BF93      		push r27
 1214 03f6 EF93      		push r30
 1215 03f8 FF93      		push r31
 1216               	/* prologue end (size=17) */
 414:../avrlib/timer.c **** 	// if a user function is defined, execute it
 415:../avrlib/timer.c **** 	if(TimerIntFunc[TIMER1OVERFLOW_INT])
 1218               	.LM117:
 1219 03fa 8091 0000 		lds r24,TimerIntFunc+2
 1220 03fe 9091 0000 		lds r25,(TimerIntFunc+2)+1
 1221 0402 892B      		or r24,r25
 1222 0404 29F0      		breq .L61
 416:../avrlib/timer.c **** 		TimerIntFunc[TIMER1OVERFLOW_INT]();
 1224               	.LM118:
 1225 0406 E091 0000 		lds r30,TimerIntFunc+2
 1226 040a F091 0000 		lds r31,(TimerIntFunc+2)+1
 1227 040e 0995      		icall
 1228               	.L61:
 1229               	/* epilogue: frame size=0 */
 1230 0410 FF91      		pop r31
 1231 0412 EF91      		pop r30
 1232 0414 BF91      		pop r27
 1233 0416 AF91      		pop r26
 1234 0418 9F91      		pop r25
 1235 041a 8F91      		pop r24
 1236 041c 7F91      		pop r23
 1237 041e 6F91      		pop r22
 1238 0420 5F91      		pop r21
 1239 0422 4F91      		pop r20
 1240 0424 3F91      		pop r19
 1241 0426 2F91      		pop r18
 1242 0428 0F90      		pop __tmp_reg__
 1243 042a 0FBE      		out __SREG__,__tmp_reg__
 1244 042c 0F90      		pop __tmp_reg__
 1245 042e 1F90      		pop __zero_reg__
 1246 0430 1895      		reti
 1247               	/* epilogue end (size=17) */
 1248               	/* function __vector_8 size 45 (11) */
 1250               	.Lscope28:
 1253               	.global	__vector_4
 1255               	__vector_4:
 417:../avrlib/timer.c **** }
 418:../avrlib/timer.c **** 
 419:../avrlib/timer.c **** #ifdef TCNT2	// support timer2 only if it exists
 420:../avrlib/timer.c **** //! Interrupt handler for tcnt2 overflow interrupt
 421:../avrlib/timer.c **** TIMER_INTERRUPT_HANDLER(SIG_OVERFLOW2)
 422:../avrlib/timer.c **** {
 1257               	.LM119:
 1258               	/* prologue: frame size=0 */
 1259 0432 1F92      		push __zero_reg__
 1260 0434 0F92      		push __tmp_reg__
 1261 0436 0FB6      		in __tmp_reg__,__SREG__
 1262 0438 0F92      		push __tmp_reg__
 1263 043a 1124      		clr __zero_reg__
 1264 043c 2F93      		push r18
 1265 043e 3F93      		push r19
 1266 0440 4F93      		push r20
 1267 0442 5F93      		push r21
 1268 0444 6F93      		push r22
 1269 0446 7F93      		push r23
 1270 0448 8F93      		push r24
 1271 044a 9F93      		push r25
 1272 044c AF93      		push r26
 1273 044e BF93      		push r27
 1274 0450 EF93      		push r30
 1275 0452 FF93      		push r31
 1276               	/* prologue end (size=17) */
 423:../avrlib/timer.c **** 	Timer2Reg0++;			// increment low-order counter
 1278               	.LM120:
 1279 0454 8091 0000 		lds r24,Timer2Reg0
 1280 0458 9091 0000 		lds r25,(Timer2Reg0)+1
 1281 045c A091 0000 		lds r26,(Timer2Reg0)+2
 1282 0460 B091 0000 		lds r27,(Timer2Reg0)+3
 1283 0464 0196      		adiw r24,1
 1284 0466 A11D      		adc r26,__zero_reg__
 1285 0468 B11D      		adc r27,__zero_reg__
 1286 046a 8093 0000 		sts Timer2Reg0,r24
 1287 046e 9093 0000 		sts (Timer2Reg0)+1,r25
 1288 0472 A093 0000 		sts (Timer2Reg0)+2,r26
 1289 0476 B093 0000 		sts (Timer2Reg0)+3,r27
 424:../avrlib/timer.c **** 
 425:../avrlib/timer.c **** 	// if a user function is defined, execute it
 426:../avrlib/timer.c **** 	if(TimerIntFunc[TIMER2OVERFLOW_INT])
 1291               	.LM121:
 1292 047a 8091 0000 		lds r24,TimerIntFunc+10
 1293 047e 9091 0000 		lds r25,(TimerIntFunc+10)+1
 1294 0482 892B      		or r24,r25
 1295 0484 29F0      		breq .L63
 427:../avrlib/timer.c **** 		TimerIntFunc[TIMER2OVERFLOW_INT]();
 1297               	.LM122:
 1298 0486 E091 0000 		lds r30,TimerIntFunc+10
 1299 048a F091 0000 		lds r31,(TimerIntFunc+10)+1
 1300 048e 0995      		icall
 1301               	.L63:
 1302               	/* epilogue: frame size=0 */
 1303 0490 FF91      		pop r31
 1304 0492 EF91      		pop r30
 1305 0494 BF91      		pop r27
 1306 0496 AF91      		pop r26
 1307 0498 9F91      		pop r25
 1308 049a 8F91      		pop r24
 1309 049c 7F91      		pop r23
 1310 049e 6F91      		pop r22
 1311 04a0 5F91      		pop r21
 1312 04a2 4F91      		pop r20
 1313 04a4 3F91      		pop r19
 1314 04a6 2F91      		pop r18
 1315 04a8 0F90      		pop __tmp_reg__
 1316 04aa 0FBE      		out __SREG__,__tmp_reg__
 1317 04ac 0F90      		pop __tmp_reg__
 1318 04ae 1F90      		pop __zero_reg__
 1319 04b0 1895      		reti
 1320               	/* epilogue end (size=17) */
 1321               	/* function __vector_4 size 64 (30) */
 1323               	.Lscope29:
 1326               	.global	__vector_6
 1328               	__vector_6:
 428:../avrlib/timer.c **** }
 429:../avrlib/timer.c **** #endif
 430:../avrlib/timer.c **** 
 431:../avrlib/timer.c **** #ifdef OCR0
 432:../avrlib/timer.c **** // include support for Output Compare 0 for new AVR processors that support it
 433:../avrlib/timer.c **** //! Interrupt handler for OutputCompare0 match (OC0) interrupt
 434:../avrlib/timer.c **** TIMER_INTERRUPT_HANDLER(SIG_OUTPUT_COMPARE0)
 435:../avrlib/timer.c **** {
 436:../avrlib/timer.c **** 	// if a user function is defined, execute it
 437:../avrlib/timer.c **** 	if(TimerIntFunc[TIMER0OUTCOMPARE_INT])
 438:../avrlib/timer.c **** 		TimerIntFunc[TIMER0OUTCOMPARE_INT]();
 439:../avrlib/timer.c **** }
 440:../avrlib/timer.c **** #endif
 441:../avrlib/timer.c **** 
 442:../avrlib/timer.c **** //! Interrupt handler for CutputCompare1A match (OC1A) interrupt
 443:../avrlib/timer.c **** TIMER_INTERRUPT_HANDLER(SIG_OUTPUT_COMPARE1A)
 444:../avrlib/timer.c **** {
 1330               	.LM123:
 1331               	/* prologue: frame size=0 */
 1332 04b2 1F92      		push __zero_reg__
 1333 04b4 0F92      		push __tmp_reg__
 1334 04b6 0FB6      		in __tmp_reg__,__SREG__
 1335 04b8 0F92      		push __tmp_reg__
 1336 04ba 1124      		clr __zero_reg__
 1337 04bc 2F93      		push r18
 1338 04be 3F93      		push r19
 1339 04c0 4F93      		push r20
 1340 04c2 5F93      		push r21
 1341 04c4 6F93      		push r22
 1342 04c6 7F93      		push r23
 1343 04c8 8F93      		push r24
 1344 04ca 9F93      		push r25
 1345 04cc AF93      		push r26
 1346 04ce BF93      		push r27
 1347 04d0 EF93      		push r30
 1348 04d2 FF93      		push r31
 1349               	/* prologue end (size=17) */
 445:../avrlib/timer.c **** 	// if a user function is defined, execute it
 446:../avrlib/timer.c **** 	if(TimerIntFunc[TIMER1OUTCOMPAREA_INT])
 1351               	.LM124:
 1352 04d4 8091 0000 		lds r24,TimerIntFunc+4
 1353 04d8 9091 0000 		lds r25,(TimerIntFunc+4)+1
 1354 04dc 892B      		or r24,r25
 1355 04de 29F0      		breq .L65
 447:../avrlib/timer.c **** 		TimerIntFunc[TIMER1OUTCOMPAREA_INT]();
 1357               	.LM125:
 1358 04e0 E091 0000 		lds r30,TimerIntFunc+4
 1359 04e4 F091 0000 		lds r31,(TimerIntFunc+4)+1
 1360 04e8 0995      		icall
 1361               	.L65:
 1362               	/* epilogue: frame size=0 */
 1363 04ea FF91      		pop r31
 1364 04ec EF91      		pop r30
 1365 04ee BF91      		pop r27
 1366 04f0 AF91      		pop r26
 1367 04f2 9F91      		pop r25
 1368 04f4 8F91      		pop r24
 1369 04f6 7F91      		pop r23
 1370 04f8 6F91      		pop r22
 1371 04fa 5F91      		pop r21
 1372 04fc 4F91      		pop r20
 1373 04fe 3F91      		pop r19
 1374 0500 2F91      		pop r18
 1375 0502 0F90      		pop __tmp_reg__
 1376 0504 0FBE      		out __SREG__,__tmp_reg__
 1377 0506 0F90      		pop __tmp_reg__
 1378 0508 1F90      		pop __zero_reg__
 1379 050a 1895      		reti
 1380               	/* epilogue end (size=17) */
 1381               	/* function __vector_6 size 45 (11) */
 1383               	.Lscope30:
 1386               	.global	__vector_7
 1388               	__vector_7:
 448:../avrlib/timer.c **** }
 449:../avrlib/timer.c **** 
 450:../avrlib/timer.c **** //! Interrupt handler for OutputCompare1B match (OC1B) interrupt
 451:../avrlib/timer.c **** TIMER_INTERRUPT_HANDLER(SIG_OUTPUT_COMPARE1B)
 452:../avrlib/timer.c **** {
 1390               	.LM126:
 1391               	/* prologue: frame size=0 */
 1392 050c 1F92      		push __zero_reg__
 1393 050e 0F92      		push __tmp_reg__
 1394 0510 0FB6      		in __tmp_reg__,__SREG__
 1395 0512 0F92      		push __tmp_reg__
 1396 0514 1124      		clr __zero_reg__
 1397 0516 2F93      		push r18
 1398 0518 3F93      		push r19
 1399 051a 4F93      		push r20
 1400 051c 5F93      		push r21
 1401 051e 6F93      		push r22
 1402 0520 7F93      		push r23
 1403 0522 8F93      		push r24
 1404 0524 9F93      		push r25
 1405 0526 AF93      		push r26
 1406 0528 BF93      		push r27
 1407 052a EF93      		push r30
 1408 052c FF93      		push r31
 1409               	/* prologue end (size=17) */
 453:../avrlib/timer.c **** 	// if a user function is defined, execute it
 454:../avrlib/timer.c **** 	if(TimerIntFunc[TIMER1OUTCOMPAREB_INT])
 1411               	.LM127:
 1412 052e 8091 0000 		lds r24,TimerIntFunc+6
 1413 0532 9091 0000 		lds r25,(TimerIntFunc+6)+1
 1414 0536 892B      		or r24,r25
 1415 0538 29F0      		breq .L67
 455:../avrlib/timer.c **** 		TimerIntFunc[TIMER1OUTCOMPAREB_INT]();
 1417               	.LM128:
 1418 053a E091 0000 		lds r30,TimerIntFunc+6
 1419 053e F091 0000 		lds r31,(TimerIntFunc+6)+1
 1420 0542 0995      		icall
 1421               	.L67:
 1422               	/* epilogue: frame size=0 */
 1423 0544 FF91      		pop r31
 1424 0546 EF91      		pop r30
 1425 0548 BF91      		pop r27
 1426 054a AF91      		pop r26
 1427 054c 9F91      		pop r25
 1428 054e 8F91      		pop r24
 1429 0550 7F91      		pop r23
 1430 0552 6F91      		pop r22
 1431 0554 5F91      		pop r21
 1432 0556 4F91      		pop r20
 1433 0558 3F91      		pop r19
 1434 055a 2F91      		pop r18
 1435 055c 0F90      		pop __tmp_reg__
 1436 055e 0FBE      		out __SREG__,__tmp_reg__
 1437 0560 0F90      		pop __tmp_reg__
 1438 0562 1F90      		pop __zero_reg__
 1439 0564 1895      		reti
 1440               	/* epilogue end (size=17) */
 1441               	/* function __vector_7 size 45 (11) */
 1443               	.Lscope31:
 1446               	.global	__vector_5
 1448               	__vector_5:
 456:../avrlib/timer.c **** }
 457:../avrlib/timer.c **** 
 458:../avrlib/timer.c **** //! Interrupt handler for InputCapture1 (IC1) interrupt
 459:../avrlib/timer.c **** TIMER_INTERRUPT_HANDLER(SIG_INPUT_CAPTURE1)
 460:../avrlib/timer.c **** {
 1450               	.LM129:
 1451               	/* prologue: frame size=0 */
 1452 0566 1F92      		push __zero_reg__
 1453 0568 0F92      		push __tmp_reg__
 1454 056a 0FB6      		in __tmp_reg__,__SREG__
 1455 056c 0F92      		push __tmp_reg__
 1456 056e 1124      		clr __zero_reg__
 1457 0570 2F93      		push r18
 1458 0572 3F93      		push r19
 1459 0574 4F93      		push r20
 1460 0576 5F93      		push r21
 1461 0578 6F93      		push r22
 1462 057a 7F93      		push r23
 1463 057c 8F93      		push r24
 1464 057e 9F93      		push r25
 1465 0580 AF93      		push r26
 1466 0582 BF93      		push r27
 1467 0584 EF93      		push r30
 1468 0586 FF93      		push r31
 1469               	/* prologue end (size=17) */
 461:../avrlib/timer.c **** 	// if a user function is defined, execute it
 462:../avrlib/timer.c **** 	if(TimerIntFunc[TIMER1INPUTCAPTURE_INT])
 1471               	.LM130:
 1472 0588 8091 0000 		lds r24,TimerIntFunc+8
 1473 058c 9091 0000 		lds r25,(TimerIntFunc+8)+1
 1474 0590 892B      		or r24,r25
 1475 0592 29F0      		breq .L69
 463:../avrlib/timer.c **** 		TimerIntFunc[TIMER1INPUTCAPTURE_INT]();
 1477               	.LM131:
 1478 0594 E091 0000 		lds r30,TimerIntFunc+8
 1479 0598 F091 0000 		lds r31,(TimerIntFunc+8)+1
 1480 059c 0995      		icall
 1481               	.L69:
 1482               	/* epilogue: frame size=0 */
 1483 059e FF91      		pop r31
 1484 05a0 EF91      		pop r30
 1485 05a2 BF91      		pop r27
 1486 05a4 AF91      		pop r26
 1487 05a6 9F91      		pop r25
 1488 05a8 8F91      		pop r24
 1489 05aa 7F91      		pop r23
 1490 05ac 6F91      		pop r22
 1491 05ae 5F91      		pop r21
 1492 05b0 4F91      		pop r20
 1493 05b2 3F91      		pop r19
 1494 05b4 2F91      		pop r18
 1495 05b6 0F90      		pop __tmp_reg__
 1496 05b8 0FBE      		out __SREG__,__tmp_reg__
 1497 05ba 0F90      		pop __tmp_reg__
 1498 05bc 1F90      		pop __zero_reg__
 1499 05be 1895      		reti
 1500               	/* epilogue end (size=17) */
 1501               	/* function __vector_5 size 45 (11) */
 1503               	.Lscope32:
 1506               	.global	__vector_3
 1508               	__vector_3:
 464:../avrlib/timer.c **** }
 465:../avrlib/timer.c **** 
 466:../avrlib/timer.c **** //! Interrupt handler for OutputCompare2 match (OC2) interrupt
 467:../avrlib/timer.c **** TIMER_INTERRUPT_HANDLER(SIG_OUTPUT_COMPARE2)
 468:../avrlib/timer.c **** {
 1510               	.LM132:
 1511               	/* prologue: frame size=0 */
 1512 05c0 1F92      		push __zero_reg__
 1513 05c2 0F92      		push __tmp_reg__
 1514 05c4 0FB6      		in __tmp_reg__,__SREG__
 1515 05c6 0F92      		push __tmp_reg__
 1516 05c8 1124      		clr __zero_reg__
 1517 05ca 2F93      		push r18
 1518 05cc 3F93      		push r19
 1519 05ce 4F93      		push r20
 1520 05d0 5F93      		push r21
 1521 05d2 6F93      		push r22
 1522 05d4 7F93      		push r23
 1523 05d6 8F93      		push r24
 1524 05d8 9F93      		push r25
 1525 05da AF93      		push r26
 1526 05dc BF93      		push r27
 1527 05de EF93      		push r30
 1528 05e0 FF93      		push r31
 1529               	/* prologue end (size=17) */
 469:../avrlib/timer.c **** 	// if a user function is defined, execute it
 470:../avrlib/timer.c **** 	if(TimerIntFunc[TIMER2OUTCOMPARE_INT])
 1531               	.LM133:
 1532 05e2 8091 0000 		lds r24,TimerIntFunc+12
 1533 05e6 9091 0000 		lds r25,(TimerIntFunc+12)+1
 1534 05ea 892B      		or r24,r25
 1535 05ec 29F0      		breq .L71
 471:../avrlib/timer.c **** 		TimerIntFunc[TIMER2OUTCOMPARE_INT]();
 1537               	.LM134:
 1538 05ee E091 0000 		lds r30,TimerIntFunc+12
 1539 05f2 F091 0000 		lds r31,(TimerIntFunc+12)+1
 1540 05f6 0995      		icall
 1541               	.L71:
 1542               	/* epilogue: frame size=0 */
 1543 05f8 FF91      		pop r31
 1544 05fa EF91      		pop r30
 1545 05fc BF91      		pop r27
 1546 05fe AF91      		pop r26
 1547 0600 9F91      		pop r25
 1548 0602 8F91      		pop r24
 1549 0604 7F91      		pop r23
 1550 0606 6F91      		pop r22
 1551 0608 5F91      		pop r21
 1552 060a 4F91      		pop r20
 1553 060c 3F91      		pop r19
 1554 060e 2F91      		pop r18
 1555 0610 0F90      		pop __tmp_reg__
 1556 0612 0FBE      		out __SREG__,__tmp_reg__
 1557 0614 0F90      		pop __tmp_reg__
 1558 0616 1F90      		pop __zero_reg__
 1559 0618 1895      		reti
 1560               	/* epilogue end (size=17) */
 1561               	/* function __vector_3 size 45 (11) */
 1563               	.Lscope33:
 1565               		.comm TimerPauseReg,4,1
 1566               		.comm Timer0Reg0,4,1
 1567               		.comm Timer2Reg0,4,1
 1568               		.lcomm TimerIntFunc,14
 1575               		.text
 1577               	Letext:
 1578               	/* File "../avrlib/timer.c": code  797 = 0x031d ( 517), prologues 127, epilogues 153 */
DEFINED SYMBOLS
                            *ABS*:00000000 timer.c
                            *ABS*:0000003f __SREG__
                            *ABS*:0000003e __SP_H__
                            *ABS*:0000003d __SP_L__
                            *ABS*:00000000 __tmp_reg__
                            *ABS*:00000001 __zero_reg__
/var/tmp//cca6lG7e.s:98     .progmem.data:00000000 TimerRTCPrescaleFactor
/var/tmp//cca6lG7e.s:110    .progmem.data:00000010 TimerPrescaleFactor
/var/tmp//cca6lG7e.s:122    .text:00000000 delay_us
/var/tmp//cca6lG7e.s:167    .text:00000026 timerDetach
                             .bss:00000000 TimerIntFunc
/var/tmp//cca6lG7e.s:199    .text:0000003e timer0SetPrescaler
/var/tmp//cca6lG7e.s:220    .text:00000048 timer0ClearOverflowCount
                            *COM*:00000004 Timer0Reg0
/var/tmp//cca6lG7e.s:241    .text:0000005a timer0Init
/var/tmp//cca6lG7e.s:272    .text:0000006a timer1SetPrescaler
/var/tmp//cca6lG7e.s:293    .text:00000074 timer1Init
/var/tmp//cca6lG7e.s:324    .text:00000084 timer2SetPrescaler
/var/tmp//cca6lG7e.s:345    .text:0000008e timer2ClearOverflowCount
                            *COM*:00000004 Timer2Reg0
/var/tmp//cca6lG7e.s:366    .text:000000a0 timer2Init
/var/tmp//cca6lG7e.s:396    .text:000000b0 timerInit
/var/tmp//cca6lG7e.s:443    .text:000000ca timer0GetPrescaler
/var/tmp//cca6lG7e.s:481    .text:000000e2 timer1GetPrescaler
/var/tmp//cca6lG7e.s:519    .text:000000fa timer2GetPrescaler
/var/tmp//cca6lG7e.s:559    .text:00000112 timerAttach
/var/tmp//cca6lG7e.s:591    .text:0000012a timerPause
                            *COM*:00000004 TimerPauseReg
/var/tmp//cca6lG7e.s:774    .text:00000258 timer0GetOverflowCount
/var/tmp//cca6lG7e.s:799    .text:0000026e timer2GetOverflowCount
/var/tmp//cca6lG7e.s:825    .text:00000284 timer1PWMInit
/var/tmp//cca6lG7e.s:890    .text:000002b4 timer1PWMInitICR
/var/tmp//cca6lG7e.s:938    .text:000002dc timer1PWMAOff
/var/tmp//cca6lG7e.s:963    .text:000002ea timer1PWMBOff
/var/tmp//cca6lG7e.s:988    .text:000002f8 timer1PWMOff
/var/tmp//cca6lG7e.s:1019   .text:0000030a timer1PWMAOn
/var/tmp//cca6lG7e.s:1044   .text:00000318 timer1PWMBOn
/var/tmp//cca6lG7e.s:1070   .text:00000326 timer1PWMASet
/var/tmp//cca6lG7e.s:1090   .text:0000032c timer1PWMBSet
/var/tmp//cca6lG7e.s:1109   .text:00000332 __vector_9
/var/tmp//cca6lG7e.s:1195   .text:000003d8 __vector_8
/var/tmp//cca6lG7e.s:1255   .text:00000432 __vector_4
/var/tmp//cca6lG7e.s:1328   .text:000004b2 __vector_6
/var/tmp//cca6lG7e.s:1388   .text:0000050c __vector_7
/var/tmp//cca6lG7e.s:1448   .text:00000566 __vector_5
/var/tmp//cca6lG7e.s:1508   .text:000005c0 __vector_3
/var/tmp//cca6lG7e.s:1577   .text:0000061a Letext

UNDEFINED SYMBOLS
__do_copy_data
__do_clear_bss
__udivmodhi4
__divmodsi4
__mulsi3
__udivmodsi4
